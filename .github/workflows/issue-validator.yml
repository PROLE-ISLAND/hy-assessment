# =====================================================
# Issue Template Validator v2
# Ensures issues follow the defined templates
# =====================================================

name: Issue Template Validator

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

jobs:
  validate-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Validate Issue Format
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            const labels = issue.labels.map(l => l.name);

            // Skip if already has validation label
            if (labels.includes('template-valid') || labels.includes('template-bypass')) {
              console.log('Issue already validated or bypassed');
              return;
            }

            const errors = [];
            const warnings = [];
            let issueType = null;
            let requiredLabels = [];

            // =====================================================
            // Determine issue type from title prefix (æ—¥æœ¬èªžå¯¾å¿œ)
            // =====================================================
            if (title.startsWith('[æ©Ÿèƒ½]:') || title.startsWith('[æ©Ÿèƒ½]') ||
                title.startsWith('[Feature]:') || title.startsWith('[Feature]')) {
              issueType = 'feature';
              requiredLabels = ['feature', 'needs-triage', 'design-review'];
            } else if (title.startsWith('[ãƒã‚°]:') || title.startsWith('[ãƒã‚°]') ||
                       title.startsWith('[Bug]:') || title.startsWith('[Bug]')) {
              issueType = 'bug';
              requiredLabels = ['bug', 'needs-triage'];
            }

            // =====================================================
            // Validate Feature Request v2 (æ—¥æœ¬èªžã‚»ã‚¯ã‚·ãƒ§ãƒ³å¯¾å¿œ)
            // =====================================================
            if (issueType === 'feature') {
              // Required sections (Japanese primary, English fallback)
              const requiredSections = [
                { name: 'å„ªå…ˆåº¦', pattern: /### (å„ªå…ˆåº¦|Priority)\s*\n[^\n]+/i },
                { name: 'å“è³ªãƒ¬ãƒ™ãƒ«', pattern: /### (å“è³ªãƒ¬ãƒ™ãƒ«ï¼ˆDoDï¼‰|DoD Level)\s*\n[^\n]+/i },
                { name: 'æ©Ÿèƒ½èª¬æ˜Ž', pattern: /### (æ©Ÿèƒ½èª¬æ˜Ž|Feature Description)\s*\n/i },
                { name: 'èƒŒæ™¯ãƒ»å‹•æ©Ÿ', pattern: /### (èƒŒæ™¯ãƒ»å‹•æ©Ÿï¼ˆWhyï¼‰|Background)\s*\n/i },
                { name: 'ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å®šç¾©', pattern: /### (ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å®šç¾©ï¼ˆRole Ã— Outcomeï¼‰|Usecase)\s*\n/i },
                { name: 'å—ã‘å…¥ã‚Œæ¡ä»¶', pattern: /### (å—ã‘å…¥ã‚Œæ¡ä»¶|Acceptance Criteria)\s*\n/i },
                { name: 'ãƒ†ã‚¹ãƒˆè¨ˆç”»', pattern: /### (ãƒ†ã‚¹ãƒˆè¨ˆç”»|Test Plan)\s*\n/i },
              ];

              for (const section of requiredSections) {
                if (!section.pattern.test(body)) {
                  errors.push(`âŒ å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“: **${section.name}**`);
                }
              }

              // Check for pre-check confirmation
              const hasPreCheck = /é‡è¤‡IssueãŒãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸ/.test(body) &&
                                  /\[x\]/i.test(body.match(/é‡è¤‡IssueãŒãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸ[^\n]*/)?.[0] || '');
              if (!hasPreCheck) {
                errors.push('âŒ äº‹å‰ç¢ºèªãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã›ã‚“: **é‡è¤‡IssueãŒãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸ**');
              }

              // Check for Figma link in UI features
              const figmaLinkPattern = /### (Figmaãƒ¢ãƒƒã‚¯ã‚¢ãƒƒãƒ—|Figma Mockup Link)\s*\n([^\n]+)/i;
              const figmaMatch = body.match(figmaLinkPattern);
              const hasBackendOnlyCheck = /(ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®æ©Ÿèƒ½|This is a backend-only feature)/.test(body) &&
                                          /\[x\]/i.test(body.match(/(ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®æ©Ÿèƒ½|This is a backend-only feature)[^\n]*/)?.[0] || '');

              if (!hasBackendOnlyCheck) {
                if (!figmaMatch || !figmaMatch[2].includes('figma.com')) {
                  warnings.push('âš ï¸ **Figmaãƒªãƒ³ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“**: UIæ©Ÿèƒ½ã«ã¯Figmaãƒ¢ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå¿…è¦ã§ã™ã€‚ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®å ´åˆã¯ã€Œãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®æ©Ÿèƒ½ã€ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚');
                }
              }

              // Check variant checklist for UI features
              const variantChecklist = /### (ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒãƒªã‚¢ãƒ³ãƒˆ|Component Variant Checklist)/i.test(body);
              if (!hasBackendOnlyCheck && !variantChecklist) {
                warnings.push('âš ï¸ **ãƒãƒªã‚¢ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆãŒã‚ã‚Šã¾ã›ã‚“**: UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ã¯Default/Loading/Empty/Errorãƒãƒªã‚¢ãƒ³ãƒˆãŒå¿…è¦ã§ã™ã€‚');
              }

              // Check Gold E2E evaluation
              const isGoldE2E = /### Gold E2E å€™è£œã‹ï¼Ÿ\s*\n\s*ã¯ã„/i.test(body);
              const hasFiveLenses = /### 5ã¤ã®ãƒ¬ãƒ³ã‚ºè©•ä¾¡/i.test(body) && /\| ãƒ¬ãƒ³ã‚º \|/i.test(body);
              if (isGoldE2E && !hasFiveLenses) {
                warnings.push('âš ï¸ **5ã¤ã®ãƒ¬ãƒ³ã‚ºè©•ä¾¡ãŒä¸å®Œå…¨**: Gold E2Eå€™è£œã®å ´åˆã¯5ã¤ã®ãƒ¬ãƒ³ã‚ºè©•ä¾¡ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¨˜å…¥ã—ã¦ãã ã•ã„ã€‚');
              }

              // Check affected scope
              const hasAffectedScope = /### å½±éŸ¿ç¯„å›²/i.test(body);
              if (!hasAffectedScope) {
                warnings.push('âš ï¸ **å½±éŸ¿ç¯„å›²ãŒæœªé¸æŠž**: ãƒ•ãƒ­ãƒ³ãƒˆ/ãƒãƒƒã‚¯/DB/ã‚¤ãƒ³ãƒ•ãƒ©ã®å½±éŸ¿ç¯„å›²ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚');
              }
            }

            // =====================================================
            // Validate Bug Report (æ—¥æœ¬èªžã‚»ã‚¯ã‚·ãƒ§ãƒ³å¯¾å¿œ)
            // =====================================================
            if (issueType === 'bug') {
              const requiredSections = [
                { name: 'å„ªå…ˆåº¦', pattern: /### (å„ªå…ˆåº¦|Priority)\s*\n[^\n]+/i },
                { name: 'å“è³ªãƒ¬ãƒ™ãƒ«', pattern: /### (å“è³ªãƒ¬ãƒ™ãƒ«ï¼ˆDoDï¼‰|DoD Level)\s*\n[^\n]+/i },
                { name: 'ãƒã‚°ã®èª¬æ˜Ž', pattern: /### (ãƒã‚°ã®èª¬æ˜Ž|Bug Description)\s*\n/i },
                { name: 'å†ç¾æ‰‹é †', pattern: /### (å†ç¾æ‰‹é †|Steps to Reproduce)\s*\n/i },
                { name: 'æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ', pattern: /### (æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ|Expected Behavior)\s*\n/i },
                { name: 'å½±éŸ¿ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«', pattern: /### (å½±éŸ¿ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«|Affected Files)\s*\n/i },
                { name: 'ãƒ†ã‚¹ãƒˆè¨ˆç”»', pattern: /### (ãƒ†ã‚¹ãƒˆè¨ˆç”»|Test Plan)\s*\n/i },
                { name: 'å—ã‘å…¥ã‚Œæ¡ä»¶', pattern: /### (å—ã‘å…¥ã‚Œæ¡ä»¶|Acceptance Criteria)\s*\n/i },
              ];

              for (const section of requiredSections) {
                if (!section.pattern.test(body)) {
                  errors.push(`âŒ å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“: **${section.name}**`);
                }
              }
            }

            // =====================================================
            // Check if no template was used
            // =====================================================
            if (!issueType) {
              // Check if body looks like it used a template
              const hasTemplateStructure = /### (å„ªå…ˆåº¦|Priority|èƒŒæ™¯|Background|ãƒã‚°ã®èª¬æ˜Ž|Bug Description)/i.test(body);

              if (!hasTemplateStructure) {
                errors.push('âŒ **IssueãŒãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå½¢å¼ã«å¾“ã£ã¦ã„ã¾ã›ã‚“ã€‚** Issueä½œæˆæ™‚ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„:');
                errors.push('  - [æ©Ÿèƒ½è¦æœ›](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/issues/new?template=feature_request.yml)');
                errors.push('  - [ãƒã‚°å ±å‘Š](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/issues/new?template=bug_report.yml)');
              } else {
                // Has structure but wrong title prefix
                errors.push('âŒ **ã‚¿ã‚¤ãƒˆãƒ«å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚** `[æ©Ÿèƒ½]: ...` ã¾ãŸã¯ `[ãƒã‚°]: ...` ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
              }
            }

            // =====================================================
            // Check labels
            // =====================================================
            if (issueType && requiredLabels.length > 0) {
              const missingLabels = requiredLabels.filter(l => !labels.includes(l));
              if (missingLabels.length > 0) {
                // Auto-add missing labels
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: missingLabels
                  });
                  console.log('Added missing labels:', missingLabels);
                } catch (e) {
                  console.error('Failed to add labels:', e);
                }
              }
            }

            // =====================================================
            // Post validation result comment
            // =====================================================
            if (errors.length > 0 || warnings.length > 0) {
              let comment = '## ðŸ“‹ Issueãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ¤œè¨¼\n\n';

              if (errors.length > 0) {
                comment += '### ã‚¨ãƒ©ãƒ¼ï¼ˆä¿®æ­£å¿…é ˆï¼‰\n\n';
                comment += errors.join('\n') + '\n\n';
                comment += '> **æ³¨æ„**: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å¾“ã£ã¦ã„ãªã„Issueã¯ã€ã‚¯ãƒ­ãƒ¼ã‚ºã¾ãŸã¯ç·¨é›†ãŒå¿…è¦ã«ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚\n\n';
              }

              if (warnings.length > 0) {
                comment += '### è­¦å‘Š\n\n';
                comment += warnings.join('\n') + '\n\n';
              }

              comment += '---\n';
              comment += '*ã“ã‚Œã¯è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã§ã™ã€‚æ„å›³çš„ã«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹å ´åˆã¯ `template-bypass` ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚*';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: comment
              });

              // Add needs-template-fix label for errors
              if (errors.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-template-fix']
                });
              }
            } else if (issueType) {
              // All checks passed
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['template-valid']
              });

              console.log('Issue validation passed');
            }
